/*
 *  ZEUS - An Electrifying Build System
 *  Copyright (c) 2017 Philipp Mieden <dreadl0ck [at] protonmail [dot] ch>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package main

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/Sirupsen/logrus"
	"github.com/dreadl0ck/readline"
	"github.com/mgutz/ansi"
)

var (
	// ErrInvalidCommand means the command name is invalid, most likely empty.
	ErrInvalidCommand = errors.New("invalid command")

	// ErrInvalidArgumentType means the argument type does not match the expected type
	ErrInvalidArgumentType = errors.New("invalid argument type")

	// ErrInvalidArgumentLabel means the argument label does not match the expected label
	ErrInvalidArgumentLabel = errors.New("invalid argument label")

	// ErrInvalidDependency means the named dependency command does not exist
	ErrInvalidDependency = errors.New("invalid dependency")

	// ErrUnsupportedLanguage means the language identifier set on the command is not supported
	ErrUnsupportedLanguage = errors.New("unsupported scripting language")
)

type commandMap struct {
	items map[string]*command
	sync.RWMutex
}

func newCommandMap() *commandMap {
	return &commandMap{
		items: make(map[string]*command, 0),
	}
}

// command represents a parsed script in memory
type command struct {

	// the path where the script resides
	path string

	// language identifier
	// set automatically via fileExtension
	language string

	// commandName
	name string

	// arguments for the command
	// mapped labels to commandArg instances
	args map[string]*commandArg

	// parameters that can be set, for calling commands with arguments in commandChains
	params []string

	// short descriptive text
	description string

	// manual text
	help string

	// async means the command will be detached
	async bool

	// completer for interactive shell
	PrefixCompleter *readline.PrefixCompleter

	// buildNumber
	buildNumber bool

	// if the command depends on other command(s)
	// add them here and they will be executed prior to execution of the current command
	// if their named output files do not exist
	dependencies commandChain

	// output file(s) of the command
	// if the file exists the command will not be executed
	outputs []string

	// if the command has been generated by a Zeusfile
	// the script that will be executed goes in here
	execScript string
}

// Run executes the command
func (c *command) Run(args []string, async bool) error {

	// read current globals
	parseGlobals()

	// spawn async commands in a new goroutine
	if async {
		go func() {
			err := c.Run(args, false)
			if err != nil {
				Log.WithError(err).Error("failed to run command: " + c.name)
			}
		}()
		time.Sleep(50 * time.Millisecond)
		return nil
	}

	var (
		cLog  = Log.WithField("prefix", c.name)
		start = time.Now()
	)

	err := c.handleDependencies()
	if err != nil {
		return err
	}

	if len(c.outputs) != 0 {
		// check if named outputs exist
		for _, output := range c.outputs {

			Log.Debug("checking output: ", output)

			_, err := os.Stat(output)
			if err == nil {
				// file exists, skip it
				Log.WithFields(logrus.Fields{
					"commandName": c.name,
					"output":      output,
				}).Info("skipping command because its output exists")
				return nil
			}
		}
	}

	cLog.WithFields(logrus.Fields{
		"prefix": "exec",
		"args":   args,
		"params": c.params,
	}).Debug(cp.CmdName + c.name + ansi.Reset)

	// check if parameters are set on the command
	// in this case ignore the arguments from the commandline and pass the predefined ones
	if len(c.params) > 0 {
		Log.Debug("found predefined params: ", c.params)
		args = c.params
	}

	s.Lock()
	s.currentCommand++
	s.Unlock()

	argBuffer, err := c.parseArguments(args)
	if err != nil {
		return err
	}

	cmd, script, cleanupFunc, err := c.createCommand(argBuffer)
	if err != nil {
		return err
	}

	// set host shell environment
	cmd.Env = os.Environ()

	// don't wire terminalIO for async jobs
	// they can be attached by using the procs builtin
	if !c.async {
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		cmd.Stdin = os.Stdin
	}

	// incease build number if set
	if c.buildNumber {
		projectData.Lock()
		projectData.fields.BuildNumber++
		projectData.Unlock()
		projectData.update()
	}

	s.Lock()
	if c.async {
		l.Println(printPrompt() + "[" + strconv.Itoa(s.currentCommand) + "/" + strconv.Itoa(s.numCommands) + "] detaching " + cp.Prompt + c.name + ansi.Reset)
	} else {
		l.Println(printPrompt() + "[" + strconv.Itoa(s.currentCommand) + "/" + strconv.Itoa(s.numCommands) + "] executing " + cp.Prompt + c.name + ansi.Reset)
	}
	s.Unlock()

	// lets go
	err = cmd.Start()
	if err != nil {
		cLog.WithError(err).Fatal("failed to start command: " + c.name)
	}

	// add to processMap
	var (
		id  = processID(randomString())
		pid = cmd.Process.Pid
	)
	cLog.Debug("PID: ", pid)
	addProcess(id, c.name, cmd.Process, pid)

	// after command has finished running, remove from processMap
	defer deleteProcessByPID(pid)

	// wait for command to finish execution
	err = cmd.Wait()
	if err != nil {

		// execute cleanupFunc if there is one
		if cleanupFunc != nil {
			cleanupFunc()
		}

		// when there are no globals
		// read the command script directly
		// and print it with line numbers to stdout for easy debugging
		if script == "" {
			scriptBytes, err := ioutil.ReadFile(c.path)
			if err != nil {
				cLog.WithError(err).Error("failed to read script")
			}
			script = string(scriptBytes)
		}

		if conf.fields.DumpScriptOnError {
			dumpScript(script, c.language, err)
		}

		return err
	}

	if c.async {

		// add to process map PID +1
		Log.Debug("detached PID: ", pid+1)
		addProcess(id, c.name, nil, pid+1)

		func() {
			for {

				// check if detached process is still alive
				// If sig is 0, then no signal is sent, but error checking is still performed
				// this can be used to check for the existence of a process ID or process group ID
				err := exec.Command("kill", "-0", strconv.Itoa(pid+1)).Run()
				if err != nil {
					Log.Debug("detached process with PID " + strconv.Itoa(pid+1) + " exited")
					deleteProcessByPID(pid + 1)

					// execute cleanupFunc if there is one
					if cleanupFunc != nil {
						cleanupFunc()
					}
					return
				}

				time.Sleep(2 * time.Second)
			}
		}()
	} else {
		s.Lock()
		// print stats
		l.Println(
			printPrompt()+"["+strconv.Itoa(s.currentCommand)+"/"+strconv.Itoa(s.numCommands)+"] finished "+cp.Prompt+c.name+cp.Text+" in"+cp.Prompt,
			time.Now().Sub(start),
			ansi.Reset,
		)
		s.Unlock()

		// execute cleanupFunc if there is one
		if cleanupFunc != nil {
			cleanupFunc()
		}
	}

	return nil
}

// execute dependencies for the current command
// if their named outputs do not exist
func (c *command) handleDependencies() error {

	if len(c.dependencies) > 0 {

		for _, dep := range c.dependencies {

			// check if dependency has ouputs defined
			if len(dep.outputs) > 0 {

				var outputMissing bool

				// check if all named outputs exist
				for _, output := range dep.outputs {
					_, err := os.Stat(output)
					if err != nil {
						outputMissing = true
					}
				}

				// no outputs missing
				// next iteration
				if !outputMissing {
					continue
				}
			}

			// execute dependency
			// dont pass the commandline args down the commandChain
			// if the following commands have required arguments they are set on the params fields
			err := dep.Run([]string{}, dep.async)
			if err != nil {
				Log.WithError(err).Error("failed to execute " + dep.name)
				return err
			}
		}
	}

	return nil
}

// get the language for the current command
func (c *command) getLanguage() (*Language, error) {
	ps.Lock()
	defer ps.Unlock()

	if p, ok := ps.items[c.language]; ok {
		return p.language, nil
	}

	return nil, ErrUnsupportedLanguage
}

// create an exec.Cmd instance ready for execution
// for the given argument buffer
func (c *command) createCommand(argBuffer string) (cmd *exec.Cmd, script string, cleanupFunc func(), err error) {

	var (
		shellCommand []string
		globalVars   string
		globalFuncs  string
	)

	if c.async {
		shellCommand = append(shellCommand, []string{"screen", "-L", "-S", c.name, "-dm"}...)
	}

	lang, err := c.getLanguage()
	if err != nil {
		return
	}

	var stopOnErr bool
	conf.Lock()
	stopOnErr = conf.fields.StopOnError
	conf.Unlock()

	// add interpreter
	shellCommand = append(shellCommand, lang.Interpreter)

	if stopOnErr && lang.FlagStopOnError != "" {
		shellCommand = append(shellCommand, []string{lang.FlagStopOnError, lang.FlagEvaluateScript}...)
	} else if lang.FlagEvaluateScript != "" {
		shellCommand = append(shellCommand, lang.FlagEvaluateScript)
	}

	g.Lock()

	// initialize global variables
	for name, value := range g.Items {
		globalVars += lang.VariableKeyword + name + lang.AssignmentOperator + value + "\n"
	}

	g.Unlock()

	// add language specific global code
	code, err := ioutil.ReadFile(zeusDir + "/globals" + lang.FileExtension)
	if err == nil {
		globalFuncs = string(code)
	}

	// check if loaded via Zeusfile
	if c.execScript != "" {
		script = lang.Bang + "\n" + globalVars + "\n" + globalFuncs + "\n" + argBuffer + "\n" + c.execScript
		//printScript(script, c.name)
	} else {

		// make sure script is executable
		// just in case the user wants to run it manually one day
		err = os.Chmod(c.path, 0700)
		if err != nil {
			Log.Error("failed to make script executable")
			return nil, "", nil, err
		}

		// read the contents of this commands script
		target, err := ioutil.ReadFile(c.path)
		if err != nil {
			l.Fatal(err)
		}

		script = lang.Bang + "\n" + globalVars + "\n" + globalFuncs + "\n" + argBuffer + "\n" + string(target)
	}

	// if desired write generated script into a temporary file in the scripts/.tmp directory
	// this is needed because some interpreters do not support passing multi line scripts on the commandline
	if lang.UseTempFile {

		// make sure the .tmp dir exists
		os.MkdirAll(scriptDir+"/.tmp", 0700)

		filename := scriptDir + "/.tmp/" + c.name + "_" + randomString() + lang.FileExtension

		f, err := os.Create(filename)
		if err != nil {
			Log.WithError(err).Error("failed to create tmp dir")
			return nil, "", nil, err
		}
		defer f.Close()

		f.WriteString(script)

		// make temp script executable
		err = os.Chmod(filename, 0700)
		if err != nil {
			Log.Error("failed to make script executable")
			return nil, "", nil, err
		}

		shellCommand = append(shellCommand, filename)

		// remove the generated tempfile
		cleanupFunc = func() {
			os.Remove(filename)
		}
	} else {
		shellCommand = append(shellCommand, script)
	}

	// Log.Debug("shellCommand: ", shellCommand)

	cmd = exec.Command(shellCommand[0], shellCommand[1:]...)

	if conf.fields.Debug {
		printScript(script, c.name)
	}

	return cmd, script, cleanupFunc, nil
}

/*
 *	Utils
 */

// get the default value for a commandArg's type
func getDefaultValue(arg *commandArg) string {
	switch arg.argType {
	case reflect.String:
		return ""
	case reflect.Int:
		return "0"
	case reflect.Bool:
		return "false"
	case reflect.Float64:
		return "0.0"
	default:
		return "unknown type"
	}
}

// addCommand parses the script at path, adds it to the commandMap and sets up the shell completer
// if force is set to true the command will parsed again even when it already has been parsed
func addCommand(path string, force bool) error {

	p, err := getParserForScript(path)
	if err != nil {
		return err
	}

	// check if command is currently being parsed
	if p.JobExists(path) {
		p.WaitForJob(path)
		return nil
	}

	var (
		cLog = Log.WithField("prefix", "addCommand")

		// create parse job
		job = p.AddJob(path, false)
	)

	if !force {

		commandName := strings.TrimSuffix(filepath.Base(path), p.language.FileExtension)
		cmdMap.Lock()
		_, ok := cmdMap.items[commandName]
		cmdMap.Unlock()

		if ok {
			return nil
		}
	}

	// create new command instance
	cmd, err := job.newCommand(path)
	if err != nil {
		return err
	}

	// job done
	p.RemoveJob(job)

	// add to the completer
	// when being forced the command has already been parsed
	// so we dont need to add it again
	if !force {
		completer.Lock()
		completer.Children = append(completer.Children, cmd.PrefixCompleter)
		completer.Unlock()
	}

	cmdMap.Lock()
	// add to command map
	cmdMap.items[cmd.name] = cmd
	cmdMap.Unlock()

	cp.Lock()
	cLog.Debug("added " + cp.CmdName + cmd.name + ansi.Reset + " to the command map")
	cp.Unlock()

	return nil
}

// walk all scripts in the zeus dir and setup commandMap and globals
func findCommands() {

	var (
		cLog    = Log.WithField("prefix", "findCommands")
		start   = time.Now()
		scripts []string
		// keep track of scripts that couldn't be parsed
		parseErrors      = make(map[string]error, 0)
		parseErrorsMutex = &sync.Mutex{}
	)

	// walk zeus directory and initialize scripts
	err := filepath.Walk(scriptDir, func(path string, info os.FileInfo, err error) error {

		if err != nil {
			return err
		}

		// ignore self
		if path != scriptDir {

			// ignore sub directories
			if info.IsDir() {
				return filepath.SkipDir
			}

			scripts = append(scripts, path)
		}

		return nil
	})
	if err != nil {
		cLog.WithError(err).Fatal("failed to walk zeus directory")
	}

	if len(scripts) > 10 {

		Log.Debug("parsing scripts asynchronously")

		// Asynchronous approach

		var wg sync.WaitGroup
		wg.Add(1)

		// first half
		go func() {
			for _, path := range scripts[:len(scripts)/2] {
				err := addCommand(path, false)
				if err != nil {
					Log.WithError(err).Debug("failed to add command")
					parseErrorsMutex.Lock()
					parseErrors[path] = err
					parseErrorsMutex.Unlock()
				}
			}
			wg.Done()
		}()

		wg.Add(1)

		// second half
		go func() {
			for _, path := range scripts[len(scripts)/2:] {
				err := addCommand(path, false)
				if err != nil {
					Log.WithError(err).Debug("failed to add command")
					parseErrorsMutex.Lock()
					parseErrors[path] = err
					parseErrorsMutex.Unlock()
				}
			}
			wg.Done()
		}()

		wg.Wait()
	} else {

		Log.Debug("parsing scripts sequentially")

		// sequential approach
		for _, path := range scripts {
			err := addCommand(path, false)
			if err != nil {
				Log.WithError(err).Debug("failed to add command")
				parseErrorsMutex.Lock()
				parseErrors[path] = err
				parseErrorsMutex.Unlock()
			}
		}
	}

	// print parse errors
	for path, err := range parseErrors {
		Log.WithError(err).Error("failed to parse: ", path)
	}
	// add a newline when there were parse errors
	if len(parseErrors) > 0 {
		println()
	}

	cmdMap.Lock()
	defer cmdMap.Unlock()

	// only print info when using the interactive shell
	if len(os.Args) == 1 {
		if len(cmdMap.items) == 1 {
			l.Println(cp.Text+"initialized "+cp.Prompt, "1", cp.Text+" command in: "+cp.Prompt, time.Now().Sub(start), ansi.Reset+"\n")
		} else {
			l.Println(cp.Text+"initialized "+cp.Prompt, len(cmdMap.items), cp.Text+" commands in: "+cp.Prompt, time.Now().Sub(start), ansi.Reset+"\n")
		}
	}

	// check if custom command conflicts with builtin name
	for _, name := range builtins {
		if _, ok := cmdMap.items[name]; ok {
			cLog.Error("command ", name, " conflicts with a builtin command. Please choose a different name.")
		}
	}

	var commandCompletions []readline.PrefixCompleterInterface
	for _, c := range cmdMap.items {
		commandCompletions = append(commandCompletions, readline.PcItem(c.name))
	}

	// add all commands to the completer for the help page
	for _, c := range completer.Children {
		if string(c.GetName()) == "help " {
			c.SetChildren(commandCompletions)
		}
	}
}

// dump command to stdout for debugging
func (c *command) dump() {
	w := 15
	fmt.Println("# ---------------------------------------------------------------------------------------------------------------------- #")
	fmt.Println(pad("#  cmdName", w), cp.CmdName+c.name+ansi.Reset)
	fmt.Println("# ---------------------------------------------------------------------------------------------------------------------- #")
	fmt.Println(pad("#  path", w), c.path)
	fmt.Println(pad("#  args", w), getArgumentString(c.args)+ansi.Reset)
	fmt.Println(pad("#  params", w), c.params)
	fmt.Println(pad("#  description", w), c.description)
	fmt.Println(pad("#  help", w), c.help)
	if len(c.dependencies) > 0 {
		fmt.Println(pad("#  len(dependencies)", w), len(c.dependencies))
		fmt.Println("# ====================================================================================================================== #")
		for i, cmd := range c.dependencies {
			fmt.Println("#  dependencies[" + cp.CmdName + strconv.Itoa(i) + ansi.Reset + "]")
			cmd.dump()
		}
		fmt.Println("# ====================================================================================================================== #")
	} else {
		fmt.Println(pad("#  dependencies", w), "<empty>")
	}
	fmt.Println(pad("#  buildNumber", w), c.buildNumber)
	fmt.Println(pad("#  async", w), c.async)
	fmt.Println(pad("#  outputs", w), c.outputs)
	if c.execScript != "" {
		fmt.Println(pad("#  runCommand", w))
		for _, line := range strings.Split(c.execScript, "\n") {
			l.Println("#      " + line)
		}
	} else {
		fmt.Println(pad("#  runCommand", w), "")
	}
}
